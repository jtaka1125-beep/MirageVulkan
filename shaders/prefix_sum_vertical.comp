#version 450

// Prefix Sum - Vertical Pass
// Each workgroup processes one column.
// Applied after horizontal pass to complete the SAT.
//
// Precision note: float32 prefix sums lose precision on large images because
// accumulated values grow much larger than individual pixel values, causing
// small values to be rounded away.  We use Kahan (compensated) summation to
// retain ~2x the effective mantissa bits without requiring float64 support.

layout(local_size_x = 256) in;

layout(push_constant) uniform PushConstants {
    int width;
    int height;
    int mode;  // unused in vertical pass, shared struct with horizontal
    int pad0;
};

layout(set = 0, binding = 0, r32f) coherent uniform image2D satImage;  // in-place

shared float s_data[256];

void main() {
    int col = int(gl_WorkGroupID.x);
    int tid = int(gl_LocalInvocationID.x);

    if (col >= width) return;

    int rows_per_thread = (height + 255) / 256;
    int start_row = tid * rows_per_thread;
    int end_row = min(start_row + rows_per_thread, height);

    // Phase 1: local prefix sum within stripe (Kahan compensated)
    float running = 0.0;
    float comp = 0.0;  // Kahan compensation
    for (int row = start_row; row < end_row; row++) {
        float val = imageLoad(satImage, ivec2(col, row)).r;
        float y = val - comp;
        float t = running + y;
        comp = (t - running) - y;
        running = t;
        imageStore(satImage, ivec2(col, row), vec4(running, 0, 0, 0));
    }

    s_data[tid] = running;
    barrier();

    // Phase 2: sequential prefix across stripes (Kahan compensated)
    if (tid == 0) {
        float acc = 0.0;
        float c = 0.0;
        for (int i = 0; i < 256; i++) {
            float tmp = s_data[i];
            s_data[i] = acc;
            float y = tmp - c;
            float t = acc + y;
            c = (t - acc) - y;
            acc = t;
        }
    }
    barrier();

    // Phase 3: add prefix
    memoryBarrierImage();
    float prefix = s_data[tid];
    if (prefix != 0.0) {
        for (int row = start_row; row < end_row; row++) {
            float val = imageLoad(satImage, ivec2(col, row)).r;
            imageStore(satImage, ivec2(col, row), vec4(val + prefix, 0, 0, 0));
        }
    }
}
