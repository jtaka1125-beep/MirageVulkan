"""
mirage_api_device.py
Python helper for AOA blocks.

Talks to MacroApiServer (MirageGUI) via JSON-RPC on localhost:19840.
Server handles AOA HID first, ADB fallback automatically.

Usage (generated by Blockly AOA blocks):
    from mirage_api_device import MirageApiDevice
    device = MirageApiDevice(device_id=DEVICE_ID, host="127.0.0.1", port=19840)
    device.aoa_tap(540, 960)
"""

import socket
import json
import time
import logging

log = logging.getLogger(__name__)

# Set DEVICE_ID before running (generated code sets this from --device arg)
DEVICE_ID = "__default__"


class MirageApiDevice:
    """JSON-RPC client -> MacroApiServer (localhost:19840) -> AOA/ADB."""

    def __init__(self, device_id: str = "__default__",
                 host: str = "127.0.0.1", port: int = 19840,
                 timeout: float = 5.0):
        self._device_id = device_id
        self._host = host
        self._port = port
        self._timeout = timeout
        self._seq = 0

    # ── internal RPC ─────────────────────────────────────────────────────────

    def _call(self, method: str, **params) -> dict:
        """Send one JSON-RPC request, return result dict."""
        self._seq += 1
        req = {
            "id": self._seq,
            "method": method,
            "params": {"device_id": self._device_id, **params}
        }
        payload = json.dumps(req, ensure_ascii=False) + "\n"

        try:
            sock = socket.create_connection((self._host, self._port),
                                            timeout=self._timeout)
            sock.sendall(payload.encode("utf-8"))

            buf = b""
            while b"\n" not in buf:
                chunk = sock.recv(4096)
                if not chunk:
                    break
                buf += chunk
            sock.close()

            resp = json.loads(buf.decode("utf-8").strip())
            if "error" in resp:
                log.warning("RPC error [%s]: %s", method, resp["error"])
                return {}
            return resp.get("result", {})

        except ConnectionRefusedError:
            log.error("MacroApiServer not running on %s:%d  "
                      "(start MirageGUI first)", self._host, self._port)
            raise
        except Exception as e:
            log.error("RPC [%s] failed: %s", method, e)
            raise

    # ── タッチ操作 ────────────────────────────────────────────────────────────

    def aoa_tap(self, x: int, y: int) -> dict:
        log.info("aoa_tap(%d, %d)", x, y)
        return self._call("tap", x=x, y=y)

    def aoa_swipe(self, x1: int, y1: int, x2: int, y2: int,
                  duration_ms: int = 300) -> dict:
        log.info("aoa_swipe(%d,%d)->(%d,%d) %dms", x1, y1, x2, y2, duration_ms)
        return self._call("swipe", x1=x1, y1=y1, x2=x2, y2=y2,
                          duration_ms=duration_ms)

    def aoa_long_press(self, x: int, y: int, duration_ms: int = 1000) -> dict:
        log.info("aoa_long_press(%d, %d, %dms)", x, y, duration_ms)
        return self._call("long_press", x=x, y=y, duration_ms=duration_ms)

    def aoa_multi_touch(self, x1: int, y1: int, x2: int, y2: int,
                        duration_ms: int = 200) -> dict:
        """AOA HID 2-finger simultaneous touch. ADB cannot do this."""
        log.info("aoa_multi_touch (%d,%d)+(%d,%d) %dms",
                 x1, y1, x2, y2, duration_ms)
        return self._call("multi_touch",
                          x1=x1, y1=y1, x2=x2, y2=y2, duration_ms=duration_ms)

    def aoa_pinch(self, direction: str, cx: int, cy: int,
                  d_start: int = 400, d_end: int = 100) -> dict:
        """AOA HID pinch. direction: 'in'=縮小 / 'out'=拡大"""
        log.info("aoa_pinch(%s) cx=%d cy=%d d=%d->%d",
                 direction, cx, cy, d_start, d_end)
        return self._call("pinch", direction=direction, cx=cx, cy=cy,
                          d_start=d_start, d_end=d_end)

    # ── キー操作 ──────────────────────────────────────────────────────────────

    def aoa_key(self, keycode: int) -> dict:
        log.info("aoa_key(%d)", keycode)
        return self._call("key", keycode=keycode)

    # ── 画面 ──────────────────────────────────────────────────────────────────

    def aoa_screenshot(self, filename: str = "screenshot.png") -> dict:
        log.info("aoa_screenshot -> %s", filename)
        result = self._call("screenshot")
        if "base64" in result:
            import base64
            data = base64.b64decode(result["base64"])
            with open(filename, "wb") as f:
                f.write(data)
            log.info("Saved: %s (%d bytes)", filename, len(data))
        return result

    def aoa_has_text(self, text: str) -> bool:
        """OCR check: returns True if text found on screen."""
        log.info("aoa_has_text('%s')", text)
        result = self._call("ocr_has_text", query=text)
        return bool(result.get("found", False))

    def aoa_tap_text(self, text: str) -> dict:
        """OCR find text and tap it."""
        log.info("aoa_tap_text('%s')", text)
        return self._call("ocr_tap_text", query=text)

    # ── アプリ ────────────────────────────────────────────────────────────────

    def aoa_launch_app(self, package: str) -> dict:
        log.info("aoa_launch_app('%s')", package)
        return self._call("launch_app", package=package)

    def aoa_force_stop(self, package: str) -> dict:
        log.info("aoa_force_stop('%s')", package)
        return self._call("force_stop", package=package)

    # ── ユーティリティ ────────────────────────────────────────────────────────

    def ping(self) -> bool:
        try:
            result = self._call("ping")
            return result.get("status") == "ok"
        except Exception:
            return False

    def get_screen_size(self) -> tuple:
        info = self._call("device_info")
        return info.get("screen_w", 1080), info.get("screen_h", 1920)
